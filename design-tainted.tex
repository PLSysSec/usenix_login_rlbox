\para{Design pattern 1: Wrap untrusted data in \tainted type}
%
This means that when calling a function in the sandboxed library that 
returns in \code{int}, this must return a \taintedW{int} instead.
%
Similarly when sandboxed code invokes a permitted callback in the application 
code, all parameters to the callback must be \tainted.
%
Wrapping such untrusted data in \tainted types, imposes a monadic interface on 
this data which allows us to prevent potentially unsafe operations such as 
performing an array access with untrusted indexes.
%
For instance, consider the code below which invokes to sandboxed functions from 
a host application.
%
\begin{minted}[linenos=false, breaklines=true, mathescape=true,
escapeinside=||]{cpp}
int numbers[] = {24, 48, 72};
int i = sandboxed_get_index();
// We want a compiler error below
int num = numbers[i]; 
sandboxed_set_value(num);
\end{minted}
%
It is important to disallow this pattern: since \code{i} is untrusted, 
indexing into the array \code{numbers} may result in an out of bounds 
read operation which is then passed back to the untrusted code forming an 
arbitrary read gadget.
%
The \sys API does by providing an API called \code{invoke_sbx_func} tha 
takes the function name as a parameter and automatically wraps the return value 
in a \tainted type.
%
Thus, the above code would hit a compilation error since the type of \code{i} is
\taintedW{int}.
%
This same approach can also prevent other unsafe operations such as branching 
on \tainted values, \tainted comparisons and more.
%
Instead of directly allowing use, \tainted data must explicitly require a 
validation function be used as below
%
\begin{minted}[linenos=false, breaklines=true, mathescape=true,
escapeinside=||]{cpp}
int i_checked = i.verify([](int val){
  runtime_assert(i >= 0 && i <= 2);
});
\end{minted}
%
Here, the compiler cannot check the correctness of the validation function, but 
developers would at least get an error if they have used the value without any 
checking.
%
This design pattern ensures that application developers do not use untrusted 
data with validation by accident.
%
While some prior sandboxing APIs~\cite{codejail, google-sandboxed-api} do wrap 
some of te untrusted data, most SFI toolchain APIs do not do this. 
%
Even toolchains that wrap untrusted data do not always do so consistently (they 
wrap data returned from untrusted functions, but not the parameters of 
callbacks).

However wrapping untrusted data is a much more general pattern and can be 
applied in other well known security boundaries.
%
For instance, operating system kernel code frequently handle userspace 
pointers, but must be careful to never dereference them before checking. 
%
In fact, prior work~\cite{cqual-kernel-ptr} has proposed using C's attributes 
feature to achieve the same affect of having a wrapped type.
%
Another example are applications running on the trusted execution environments 
such as Intel SGX~\tocite{sgx} must frequently interface with untrusted code; 
indeed code from the host OS is also untrusted in this context.
%
In fact, when reviewing a variety of TEE runtimes, Van Bulck et 
al.~\cite{two-worlds-sgx} encounter a that almost all frameworks have gubs 
pertaining to use of unchecked data.
%
The problems discussed in this SGX context, have a substantial overlap with the 
problems we independently discovered later trying to safely used sandboxed 
libraries when we challenge of using sandboxed libraries that indeed prompted 
the need for the \sys API. 
%
Wrapping untrusted data is a simple but powerful idea and can largely reduce 
this type of bugs by leveraging the compiler checking in static type systems.

However, this still does not reduce the burden on application developers to 
write validation checks themselves---the next two design patterns focus on this.