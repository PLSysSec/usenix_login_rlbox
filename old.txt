
----
---- OLD STUFF
----


# Why now?

Sandboxing third party libraries is not a novel idea. These concepts have
been explored for years in academia, and has now crossed critical milestones
that make them practical. Trends in compiler toolchains and processors
architectures make efficient in-process isolation increasingly practical
without resorting to exotic techniques e.g. WebAssembly is becoming a defacto
standard tool chain for software based fault isolation, multi-core and even
minion processors support the use of multiple protection domains without
prohibitive overheads, and emerging architecture features such as Intel MPK
and ARM-Cheri allow in-process isolation with very low overhead.

Next, as our own work on Firefox in collabortation with colleuages at Mozilla
has illustrated, the software engineering problems of sandboxing, including
efficienty porting libraries into a sandboxed environment, and ensuring that
interactions between the sandboxed library and trusted application can be
secured without expert knowledge, are practical.

Finally, languages like Rust offer the ability to greatly reduce or eliminate memory
safety bugs in new code, however, this code may still use dependencies written in C,
potentially negating the memory safety benefits of Rust.


# Vision
---------


In this article we argue that this perspective needs to be updated, its time
to make compartmentalization mainstream. Much as one would ask today, "why
does this need to be running in the OS kernel", we hope in the future developers
will ask, "why does this module or dependency need to run in the applications
trusted computing base".


-------
# RLBox framework

# Sandboxing for everyone: what we need and why



What do we need to make this possible. Need sufficient language support--
meta-programming or DSL and need standardized framework that uses this stuff.


Similar opportunities exist in any any messaging (e.g. signal, telegram,
whatsapp) or social media application (facebook, instagram), will rely on a
similar collection of third party libraries for media rendering, as well as
functionality like spell checking and autocomplete.

Once the sandboxing hammer widely available, developers will start looking
for other nails.

In the rest of this article we will lay out the path to making library sandboxing
a goto tool in more software engineering environments. 

How RLbox works, and how it leverages the C++ type systems.
What we need to do this in other languages.

How this could change the way we develop software.
    -designing with sandboxing at start (trusted core, less trusted periphery)
    -package ecosystems with sandboxing built in (wasm ecosystem example)


\paragraph{Sandboxing in Firefox: Third Party code and Beyond}

The Firefox renderer, like that of every other browser has until recently
been built as a trusted monolith, with all modules and third party libraries
being totally trusted. As a consequence a vulnerability e.g. a memory safety
bug, in any one of these compromises the entire renderer i.e. the entire web
application being rendered.

In collaboration with colleauges at Mozilla, we have been moving Firefox away
from this model, and towards a model where third party libraries e.g., image,
audio, and video decoders, as well as other modules e.g. the spell checker
are run in isolated sandboxes. This effectively partitions the renderer into
two parts, a more trusted core, and a less trusted periphery consisting of
many modules who simply donâ€™t need the same level of privilege, nor to live
in the same address space as the the trusted core.

We believe this approach has relevance far beyond Firefox, and that many
modern applications can benefit from a similar approach.

Obvious first examples include mobile applications whose structure in simple
ways mirrors that of the renderer. For example, any messaging (e.g. signal,
telegram, whatsapp) or social media application (facebook, instagram), will
rely on a similar collection of third party libraries for media rendering, as
well as functionality like spell checking and autocomplete.

However, we believe additional examples will abound if more developers embrace this pattern. 

In modern applications all code is trusted by default.  This makes them excessively fragile,
especially as a large fraction of this code consists of third-party dependencies, written by different developers, of different trustworthiness. Security vulnerabilities in dependencies today often manifest as security vulnerabilities in the application using the dependencies.

This also creates a tension between developer productivity and security, since as new features are added to an application, the trusted computing base grows larger. Inevitably the need for greater functionality and productivity trumps 

This is a dumb way to build modern software, because it makes application unnecessarily fragile


 An enormous amount of software
is written in C/C++, including the native code underlying many modules in ``safe''
languages such as Python. In these settings a vulnerability in any part
of the application, or its libraries often compromises the entire application.


Code bases evolve.
We have come to view this tension between security and functionality or even
productivity, and this is not fundamental, its an artifact of monolithic
application architectures. <Example showing how functionality can be
added without diminishing security>

Why your code should be sandboxed.

-because third party libraries
-because code quality varies e.g., outsource, legacy code, blah. and
 shouldn't be security critical.
-because securing code is difficult/to impossible, slows down feature
velocity, and is expensive, and lots of people just don't do it.

\section{Why now is the time for more sandboxing?}



\section{Secure Sandboxing for Everyone}
-existing approaches coarse grain/manaul
-security is hard blah (some code examples from rlbox paper section 3?)
-porting is hard blah (want to minimize changes to libraries and application)
-leverage C++ types/compiler/etc. support to make this usable.

\section{The beautiful future}
-common framwork for sandboxing as part of language ecosystem
-other languages?


\section{}