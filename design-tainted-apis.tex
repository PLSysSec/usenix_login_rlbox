\para{Design pattern 2: Construct APIs with \tainted types}
%
Consider the validator required for the following piece of code.
%
\begin{minted}[linenos=false, breaklines=true, mathescape=true,
escapeinside=||]{cpp}
tainted<char*> src = invoke_sbx_func(sandbox_get_src);
tainted<char*> dst = invoke_sbx_func(sandbox_get_dst);
unsigned int num = ...;

memcpy(dst.verify(??), src.verify(??), num);
\end{minted}
%
Here the application code retrieves the location of some source and destination 
byte buffer located in sandbox memory and must transfer a certain number of 
bytes between them.
%
To use \code{memcpy}, the application developer must apply some validation to 
the \code{dst} and \code{src} buffers.
%
In this case, the validation check is a more subtle than it may appear---to 
ensure that \code{memcpy} does not inadvertently read or write application 
memory, the validation check must ensure that both \code{dst + num} and 
\code{src + num} is inside sandbox memory \emph{and} that the addition 
operation has not overflowed.
%
Rather than requiring application developers to get all of these checks 
correct, the \sys library provides an overloaded version of \code{memcpy} that 
accepts \tainted parameters and includes the required checks.
%
The \sys library also includes overloads of \code{memcpy} that take just one 
\tainted parameter and applies appropriate checks.

Even outside compartmentalization, this pattern can be generalized to prevent 
large classes of security attacks.
%
For instance consider the APIs provided by programming languages to get user 
input such as \code{scanf}, \code{getline}, \code{cin} etc.
%
If these returned \tainted (or wrapped values) rather than raw values, this 
would automatically prevent \code{printf} format string bugs~\tocite{} (code 
that passes unsanitized strings as the first parameter to printf).
%
Additionally APIs that do not use format strings such \code{puts} would accept 
either a raw or \tainted strings.
%
The same approach would also allow us to prevent SQL injection 
attacks~\tocite{} (where 
unsanitized input is appended to a SQL command allowing modification or 
exfiltration of SQL data), some forms of path traversal attacks (where 
unsanitized input is used as a path).
%
Perhaps the most interesting example here are from unsanitized regular 
expressions.
%
Regular expression engines typically use one of two possible algorithms---a 
polynomial time algorithm which is fast for most inputs~\tocite{} but have 
certain pathological cases that take a long time, or, a linear time algorithm 
with a large constant that typically takes longer to execute that the first 
algorithm but does not have pathologically slow cases~\tocite{}.
%
Webservers must thus be careful to never process unsanitized user provided 
regexes with the polynomial time algorithm, as it allows an attacker to 
leverage this for denial of service attacks on the server.
%
If the webserver wraps any user provided regex in a \tainted (or wrapper) type, 
and additionally setup up the regex APIs such that the linear algorithm is run 
on \tainted regexes while the polynomial time algorithm is run on raw regexes, 
this class of attacks can be automatically eliminated.