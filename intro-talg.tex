Compartmentalization to the People: Towards first class support for enforcing
fine grain least privilege in applications

\section{}

-Most applications today are monolithic where most or all code is part of the
trusted computing base, thus, a compromise in any module or dependency leading
to a compromise of the entire application.

We argue a critial next step in the evolution towards more secure applications
is to move incrementally away from the current model where all code within a
given process/application runs with the same privilege.

To a model similar to operating systems, with a more trusted application kernel
compromising the core of the application, and more and more code is moved into
less privileged compartments (memory isolated and least os privileged
sandboxes).

While this may seem radical, this movement is already underway and supported by
current trends in the language and architecture space, and that it is critically
neccessary, and a the most simple and efficient path to address current
and emerging security issues.

-Software Vulerabilities: In general we are loosing the war to build secure
    software.  Memory safety vulnerabilities, still a huge problem, runtime
    prevention still prohibitively expensive, while good things coming, we can
    expect these will be with us for at least the next decade. Compartmentalization
    is cheap compared to alternatives at the compiler and architecture level. The
    costs associated with enforcing memory safety are the compute and storage overhead
    of managing fine grain metadata, e.g., fat pointers. Compartments can be
    much more efficient, compared to memory safety vastly less meta-data which
    is updated much less frequently.

    -Malicous dependencies: code reuse through libraries, modules, etc. are
    perhaps among the biggest boons to deveoper productivity, but in todays
    large open ecosystems are a gaping hole. 

In the past, compartmentalizing applications has been out of the conciousness
of mainstream software developers and security engineerings do to its
infrequent use in existing applications. Further, among experts it has been
percieved as either too labor intensive, to performance intensive or both.

In this article we argue that this perspective needs to be updated, its time
to make compartmentalization mainstream. Much as one would ask today, "why
does this need to be running in the kernel", we hope in the future developers
will ask, "why does this module or dependency need to run in the applications
trusted computing base".

The past performance limitations are increasingly addressed by better
support for in process isolation via new hardware and compiler
level techniques, including technologies such as intel MPK, and
arm-CHERI, and the presence of Wasm as mainstream toolchain for
doing software-based fault isolation.

We believe the fear of labor intensive engineering is based in part on the
lack of adequate support from languages, frameworks, and libraries--and
that many opportunities to naturally partition applications along existing
library and module boundaries exist today, but are simply not being exploited.

An enormous amount of code that applications fully trust today simply doesn't
need to be in the application TCB. File parsers, network protocol implementations,
media decoders, an enormous amount of code that handles untrusted data doesn't
actually need to be trusted, instead our applications trusted kernel can simply
consume the results of what these components emit. Thus, our TCB not only
gets smaller, but we can narrow the interface that handles untrusted data.

Our own work has leveraged better support for SFI to bring fine grain
compartmentalization to the Firefox renderer, where we used it to sandbox man
of the third party libraries 




\Red{
Notes---Here is how we should be going dev
Sharing is super important - libraries
Dependencies - need to reason about it. But its hard to get security
What if compartmentalization was a common pattern? Cite ff nanoprocess
What about retrofitting?
Case study : Browser seems to adopt all systems based approaches
Compartmentalization has not taken off
Lots of libraries are written in C
Compart as a pattern - provos
Previously this was difficult - people say this was easy
}

Security should be simple. Yet in practice, most software development seems to 
fall into two categories---software whose architecture decisions at every level 
is dictated by security (e.g. browsers and operating system kernels) and 
software that simply rely on best effort to avoid security bugs.
%
The missing element here are design patterns that address specific security 
concerns. 

For example, consider the use of third libraries.
%
As application developers, we are currently required to fully trust any library 
used by the application.
%
Yet there is a straightforward software pattern we can use to address this---we 
can simply sandbox third party libraries.
%
This simple pattern isolates each library in its own region memory ensuring 
that memory safety bugs in a third party library does not affect the host 
application.
%
\Red{examples for mitigations for stagefright etc. and the impact this may have 
on apps like whatsapp, signal etc.}

Despite the simplicity of this solution and its extensive study in academic 
literature, it is not common to see this pattern in real world applications.
%
When talking to application developers, there are typically three reported 
reasons for this---performance concerns, an easily available well understood 
tools around compartmentalization, and finally the engineering effort for 
changing the application architecture.
%
Let's consider each of these in turn.

First performance; despite widely held concerns about sandboxing performance, 
academia has made great improvements in performance of sandboxing over 
the last two decades.
%
Notably Native Client, and more recently WebAssembly allows sandboxing on most 
architectures for under 25\% overhead.
%
Furthermore, hardware support such as Memory Protection Keys on the Intel 
platform even allows sandboxing for under 1 or 2\%.
%
While 25\% is not zero, sandboxing libraries not on the critical path in many 
large applications would not show any noticeable overheads to the end user.
%
For instance, sandboxing image libraries in the browser would most likely be 
hidden as network latencies typically dominate the rendering of a webpage.
%
Thus, while performance is an important consideration, this is not the most 
important challenge in this space.

Next, we should consider SFI's historically prevalent challenges of easily 
available well understood tools.
%
For instance, in terms of available tools, SFI compilers are typically separate 
compiler toolchains.
%
This is because SFI uses automatically inserted dynamic checks to ensure that 
all memory accesses are restricted to a given memory region---these requires 
explicit compiler support.
%
However, this means that developers must be aware of and use multiple compiler 
toolchains to sandbox parts of their application.
%
This decision is further complicated by the fact that SFI compiler toolchains 
often do not get sustained maintenance.
%
Compilers require dedicated maintenance teams to address bugs and maintain 
support for the latest language features; given that most SFI compiler 
toolchains come from academic papers, such maintenance is not present.
%
Additionally, even projects like Native Client which had a dedicated 
engineering teams for the compiler toolchains have been deprecated, further 
adding to the challenges.
%
The landscape of SFI tools, however, has been changing with WebAssembly.
%
WebAssembly is the first SFI toolchain to enjoy native support in upstream 
LLVM, with languages like Rust even offering streamlined support for compiling 
to WebAssembly.
%
Compiling WebAssembly to native code requires standalone tools like Lucet, 
however, there appears to be widespread support, competing implementations as 
well as standardization around this effort that developers may start to build 
trust on this toolchains.

Finally, we consider the engineering effort required to build applications 
using sandboxing.
%
This has been an open problem in compartmentalization research for a long time. 
%
It is this problem that the we (along with several collaborators) have tackled 
in our USENIX 2020 paper ``Retrofitting Fine Grain Isolation in the Firefox 
Renderer''.
%
While the paper focuses on introducing fine grain sandboxing in the web 
browsers---applications that are typically written in C++, the methodology is 
general and can be adopted in any application and any language.
%
The key to the approach in the paper is a methodology, more specifically, a set 
of design patterns that allows safe use sandboxing in applications.
%
Critically, this design pattern focuses on retrofitting; i.e. rather than 
expending the effort to re-architect the entire application as was done in the 
cases of OpenSSH by Provos et al. or the use of multiple processes in browsers, 
we focus on how we can improve security while retaining the existing 
architecture of your application.

Such design patterns have not commonly existed prior to this work, and this has 
had interesting ramifications on wider adoption.
%
Specifically, the developer guidelines put out by Apple, Windows, Android etc. 
or even the best practice guidelines of specific languages cannot include 
general guidelines on when to use sandboxing in applications, or how to migrate 
an existing application to use sandboxing.
%
Thus, even more than performance or tooling concerns, this lack of design 
patterns has hindered wider adoption of sandboxing in applications.

These design patterns focus on incrementally and systematically solving the 
problem of handling an untrusted piece of code or data.
%
Indeed the need for such design patterns is not just limited to sandboxing; 
several common security boundaries share very similar challenges. 
%
For example, the OS kernel-userspace boundary, the boundary between an 
application running in a trusted execution environment and the OS, sanitizing 
data from remote procedure calls (RPCs), and even the simple case of ensuring 
that user input is safely handled by an application share similar challenges, 
and can benefit from such design patterns.

We can imagine that if such patterns were more easily available, this could 
prompt programming language designers, compiler writers and application SDK 
maintainers to provide first class support for sandboxing in languages, 
prompting wider use and securing large amounts of applications.
%
It is thus worth understanding precisely where the challenge in including 
sandboxes in applications lie.
