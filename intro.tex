\Red{
Notes---Here is how we should be going dev
Sharing is super important - libraries
Dependencies - need to reason about it. But its hard to get security
What if compartmentalization was a common pattern? Cite ff nanoprocess
What about retrofitting?
Case study : Browser seems to adopt all systems based approaches
Compartmentalization has not taken off
Lots of libraries are written in C
Compart as a pattern - provos
Previously this was difficult - people say this was easy
}

Security should be simple. Yet in practice, most software development seems to 
fall into two categories---software whose architecture decisions at every level 
is dictated by security (e.g. browsers and operating system kernels) and 
software that simply rely on best effort to avoid security bugs.
%
The missing element here are design patterns that address specific security 
concerns. 

For example, consider the use of third libraries.
%
As application developers, we are currently required to fully trust any library 
used by the application.
%
Yet there is a straightforward software pattern we can use to address this---we 
can simply sandbox third party libraries.
%
This simple pattern isolates each library in its own region memory ensuring 
that memory safety bugs in a third party library does not affect the host 
application.

Despite the simplicity of this solution and its extensive study in academic 
literature, it is not common to see this pattern in real world applications.
%
When talking to application developers, there are typically three reported 
reasons for this---performance concerns, an easily available well understood 
tools around compartmentalization, and finally the engineering effort for 
changing the application architecture.
%
Let's consider each of these in turn.

First performance; despite widely held concerns about sandboxing performance, 
academia has made great improvements in performance of sandboxing over 
the last two decades.
%
Notably Native Client, and more recently WebAssembly allows sandboxing on most 
architectures for under 25\% overhead.
%
Furthermore, hardware support such as Memory Protection Keys on the Intel 
platform even allows sandboxing for under 1 or 2\%.
%
While 25\% is not zero, sandboxing libraries not on the critical path in many 
large applications would not show any noticeable overheads to the end user.
%
For instance, sandboxing image libraries in the browser would most likely be 
hidden as network latencies typically dominate the rendering of a webpage.
%
Thus, while performance is an important consideration, this is not the most 
important challenge in this space.

Next, we should consider SFI's historically prevalent challenges of easily 
available well understood tools.
%
For instance, in terms of available tools, SFI compilers are typically separate 
compiler toolchains.
%
This is because SFI uses automatically inserted dynamic checks to ensure that 
all memory accesses are restricted to a given memory region---these requires 
explicit compiler support.
%
However, this means that developers must be aware of and use multiple compiler 
toolchains to sandbox parts of their application.
%
This decision is further complicated by the fact that SFI compiler toolchains 
often do not get sustained maintenance.
%
Compilers require dedicated maintenance teams to address bugs and maintain 
support for the latest language features; given that most SFI compiler 
toolchains come from academic papers, such maintenance is not present.
%
Additionally, even projects like Native Client which had a dedicated 
engineering teams for the compiler toolchains have been deprecated, further 
adding to the challenges.
%
The landscape of SFI tools, however, has been changing with WebAssembly.
%
WebAssembly is the first SFI toolchain to enjoy native support in upstream 
LLVM, with languages like Rust even offering streamlined support for compiling 
to WebAssembly.
%
Compiling WebAssembly to native code requires standalone tools like Lucet, 
however, there appears to be widespread support, competing implementations as 
well as standardization around this effort that developers may start to build 
trust on this toolchains.

Finally, we consider the engineering effort required to build applications 
using sandboxing.
%
This has been an open problem in compartmentalization research for a long time. 
%
It is this problem that the we (along with several collaborators) have tackled 
in our USENIX 2020 paper ``Retrofitting Fine Grain Isolation in the Firefox 
Renderer''.
%
While the paper focuses on introducing fine grain sandboxing in the web 
browsers---applications that are typically written in C++, the methodology is 
general and can be adopted in any application and any language.
%
The key to the approach in the paper is a methodology, more specifically, a set 
of design patterns that allows safe use sandboxing in applications.
%
Critically, this design pattern focuses on retrofitting; i.e. rather than 
expending the effort to re-architect the entire application as was done in the 
cases of OpenSSH by Provos et al. or the use of multiple processes in browsers, 
we focus on how we can improve security while retaining the existing 
architecture of your application.

