\section{Tainted types to the rescue}
\label{sec:tainted}
%
In this section, we introduce several design patterns that are employed the 
\sys sandboxing APIs.
%
These design patterns center around the use of \tainted---a simple wrapper 
types that allow the \sys APIs to ensure that untrusted data cannot 
be misused by application developers without too much additional burden or 
modification of application code.
%
Furthermore, they also allow incremental migration of the application code to 
use sandboxed libraries. 
%
We discuss the role of these design patterns in the \sys APIs in more detail 
below; we also generalize these design patterns and show how wrapper types may 
be leveraged to solve challenges in related problem domains.

\input{design-tainted}

\input{design-tainted-apis}

\Red{

Design pattern 3: Use a separate \vtainted type for memory under 
attacker control. Allows running checkers for TOCTOU and double fetch. 
Can also leverage things like Intel transactional memory to ``freeze'' 
the memory. This also provides an clear avenue for ABI 
conversions---\vtainted is always represented in the ABI of the 
sandboxed component while \tainted uses the application ABI. This 
automatic ABI conversion is super useful---SFI compilers have different 
ABIs. Additionally consider use of other security lowfat pointers, or 
even hardware features CHERI. It may not be possible to migrate your 
entire application to use this without breaking compatibility, or 
impacting perf. However, an automatic ABI conversion would allow you to 
apply this to selectively to higher risk components and having \tainted 
types perform the ABI conversions on boundary crossings.

Design pattern 4: Allow benign operations. Tainted computations. This 
allows the user to retain the syntax of the language --- you don't have 
to have custom constructs or have to unwrap data before doing anything 
with data. More importantly allows pushing validators further into 
code. This in turn allows converting 
checking of library invariants to application invariants, which are 
much easier to enforce. Give example of PNG. This additionally allows 
automatic lazy marshaling of data and lazy ABI conversions (see point 
2). Outside of sandboxing, this is extremely useful in general RPC 
scenarios as well---you can potentially improve performance be avoiding 
unserializing function returns when they are not needed.

Design pattern 5: Automate common security checks on tainted types. 
Some domains allow automated checks. FOr example dereferencing a 
tainted pointer during sandboxing.

Design pattern 6: Provide a clearly marked escape hatch that removed 
the tainted wrapper. This is key to incremental porting. In fact in the 
sandboxing case, we provide an additional escape hatch as well called 
the null sandbox. This is necessary so that ABI differences don't 
affect incremental porting, but additionally and allows a 
compile/runtime setting to turn off sandboxing depending on 
requirement. This also allows for downstream sandboxing.

Optional design pattern 7: Only allow tainted pointers as parameters to 
sandboxed function calls. This prevents complicated marshalling 
requirements for nested data structures going in. Same thing for 
callback returns.
}