\section{Tainted types to the rescue}

\para{Design pattern 1:} Wrap untrusted data in \tainted 
type.\medskip\\
%
This means that when calling a function in the sandboxed library that 
returns in \code{int}, this must return a \taintedW{int} instead.
%
This also applies to 

\Red{

Design pattern 1: Wrap untrusted data in a \tainted type providing a 
monadic interface. Can disallow potentially unsafe operations like 
branching on \tainted data. Can also integrate with ideas interface 
types or C++'s contract proposals (like typescript library for 
interfaces but with contracts), 
Also applies to other security boundaries. Managing untrusted data from 
userspace in the kernel - compare to cqual kernel paper. Managing 
untrusted data from syscalls in sgx apps - compare to attacks in tale 
of two worlds paper.


Design pattern 2: Construct APIs around tainted types.
This can be apply to all user input apis in a lang std library 
such as scanf, getline etc. This would certainly put some types of user 
validation bugs in more sharp focus - sql injection, path traversal 
bugs, regex DOS attacks. Languages and libraries could also safely 
provide APIs that consume tainted data in place of requiring validators 
--- a tainted regex should be processed by the poly time algorithm, 
rather than one with an exponential worst case

Design pattern 3: Use a separate \vtainted type for memory under 
attacker control. Allows running checkers for TOCTOU and double fetch. 
Can also leverage things like Intel transactional memory to ``freeze'' 
the memory. This also provides an clear avenue for ABI 
conversions---\vtainted is always represented in the ABI of the 
sandboxed component while \tainted uses the application ABI. This 
automatic ABI conversion is super useful---SFI compilers have different 
ABIs. Additionally consider use of other security lowfat pointers, or 
even hardware features CHERI. It may not be possible to migrate your 
entire application to use this without breaking compatibility, or 
impacting perf. However, an automatic ABI conversion would allow you to 
apply this to selectively to higher risk components and having \tainted 
types perform the ABI conversions on boundary crossings.

Design pattern 4: Allow benign operations. Tainted computations. This 
allows the user to retain the syntax of the language --- you don't have 
to have custom constructs or have to unwrap data before doing anything 
with data. More importantly allows pushing validators further into 
code. This in turn allows converting 
checking of library invariants to application invariants, which are 
much easier to enforce. Give example of PNG. This additionally allows 
automatic lazy marshaling of data and lazy ABI conversions (see point 
2). Outside of sandboxing, this is extremely useful in general RPC 
scenarios as well---you can potentially improve performance be avoiding 
unserializing function returns when they are not needed.

Design pattern 5: Automate common security checks on tainted types. 
Some domains allow automated checks. FOr example dereferencing a 
tainted pointer during sandboxing.

Design pattern 6: Provide a clearly marked escape hatch that removed 
the tainted wrapper. This is key to incremental porting. In fact in the 
sandboxing case, we provide an additional escape hatch as well called 
the null sandbox. This is necessary so that ABI differences don't 
affect incremental porting, but additionally and allows a 
compile/runtime setting to turn off sandboxing depending on 
requirement. This also allows for downstream sandboxing.

Optional design pattern 7: Only allow tainted pointers as parameters to 
sandboxed function calls. This prevents complicated marshalling 
requirements for nested data structures going in. Same thing for 
callback returns.
}